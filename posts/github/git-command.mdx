---
title: "Essential Git Commands Reference"
date: "2025-11-21"
summary: "A complete guide to Git initialization, file management, version control workflows, and GitHub integration for developers at all skill levels."
tags: ["git", "github", "version control", "development", "terminal", "workflow"]
---

## Introduction to Git and Version Control

Git is a distributed version control system that enables developers to track changes in their codebase, collaborate with team members, and maintain a complete history of project evolution. Understanding Git commands and workflows is essential for modern software development, whether working on personal projects or contributing to large-scale collaborative efforts.

This guide provides a comprehensive reference for Git commands, from basic initialization to advanced workflows, with practical examples and best practices for integrating with GitHub.

## Understanding the Git Workflow

Before diving into specific commands, it's important to understand Git's three-stage architecture:

1. **Working Directory**: Where you modify files and create new content
2. **Staging Area (Index)**: Where you prepare changes for commit
3. **Repository**: Where committed changes are permanently stored

This architecture allows for precise control over what changes are recorded in your project history.

## Directory and File Management Fundamentals

### Creating and Organizing Project Directories

**Create a new directory:**
```bash
mkdir myNewDirectory
```

This command creates a new folder in your current location. For nested directories, use the `-p` flag:

```bash
mkdir -p projects/web-development/frontend
```

This creates the entire directory structure in one command, even if parent directories don't exist.

**Create multiple directories simultaneously:**
```bash
mkdir src tests docs config
```

### Navigating the File System

**List directory contents:**
```bash
ls -l
```

This displays files and directories with detailed information including permissions, ownership, size, and modification date.

**List all files including hidden ones:**
```bash
ls -la
```

The `-a` flag reveals hidden files (those starting with a dot), which is crucial for seeing Git configuration files like `.git` and `.gitignore`.

**Display the current directory path:**
```bash
pwd
```

This prints the absolute path of your current working directory, helping you maintain awareness of your location in the file system.

**Navigate to a directory:**
```bash
cd myNewDirectory
```

**Navigate to parent directory:**
```bash
cd ..
```

**Navigate to home directory:**
```bash
cd ~
```

**Navigate to previous directory:**
```bash
cd -
```

## Git Repository Initialization

### Creating a New Git Repository

**Initialize Git in the current directory:**
```bash
git init
```

This command creates a `.git` subdirectory containing all necessary repository metadata and object database. The directory becomes a Git repository, ready to track changes.

**Initialize with a specific branch name:**
```bash
git init -b main
```

This initializes the repository with "main" as the default branch name, following modern naming conventions.

**Initialize a bare repository (for servers):**
```bash
git init --bare
```

Bare repositories contain only Git data without a working directory, typically used for central repositories on servers.

### Verifying Repository Status

**Check repository status:**
```bash
git status
```

This displays the current state of your working directory and staging area, showing:
- Modified files not yet staged
- Files staged for commit
- Untracked files
- Current branch information

**View status in short format:**
```bash
git status -s
```

This provides a condensed view using status codes (M for modified, A for added, ?? for untracked).

## File Creation and Editing

### Creating Files from the Command Line

**Create a file with content using echo:**
```bash
echo "Enter Your Text Here" > filename.txt
```

This creates a new file with the specified content. If the file exists, it will be overwritten.

**Append content to an existing file:**
```bash
echo "Additional content" >> filename.txt
```

The `>>` operator appends content without overwriting existing data.

**Create an empty file:**
```bash
touch newfile.js
```

The `touch` command creates an empty file or updates the timestamp of an existing file.

**Create multiple files at once:**
```bash
touch index.html style.css script.js
```

### Editing Files with Nano

**Open a file in Nano editor:**
```bash
nano filename.txt
```

Nano is a user-friendly terminal text editor with on-screen command hints.

**Nano keyboard shortcuts:**
- `Ctrl + O`: Save (write out) the file
- `Ctrl + X`: Exit Nano
- `Ctrl + K`: Cut the current line
- `Ctrl + U`: Paste the cut text
- `Ctrl + W`: Search for text
- `Ctrl + \`: Search and replace
- `Ctrl + G`: Display help

**Save and exit workflow:**
1. Press `Ctrl + X` to exit
2. Press `Y` to confirm saving changes
3. Press `Enter` to confirm the filename

### Alternative Text Editors

**Using Vim:**
```bash
vim filename.txt
```

Vim is a powerful modal editor. Basic commands:
- Press `i` to enter insert mode
- Press `Esc` to return to normal mode
- Type `:w` to save
- Type `:q` to quit
- Type `:wq` to save and quit

**Using VS Code from terminal:**
```bash
code filename.txt
```

This opens the file in Visual Studio Code (if installed and configured).

## Staging Files for Commit

### Adding Files to the Staging Area

**Stage all files in the current directory:**
```bash
git add .
```

This stages all new, modified, and deleted files in the current directory and subdirectories.

**Stage all files in the repository:**
```bash
git add -A
```

The `-A` flag stages all changes throughout the entire repository, regardless of your current directory.

**Stage specific files:**
```bash
git add filename1.txt filename2.js
```

**Stage files by pattern:**
```bash
git add *.js
```

This stages all JavaScript files in the current directory.

**Stage files interactively:**
```bash
git add -p
```

This allows you to review and stage changes in chunks, providing fine-grained control over what gets committed.

**Stage only modified and deleted files (not new files):**
```bash
git add -u
```

### Managing Empty Directories

Git doesn't track empty directories. To preserve directory structure:

**Create a .gitkeep file:**
```bash
touch .gitkeep
```

Place this file in empty directories you want to track. The `.gitkeep` convention signals that the directory should be preserved in the repository.

**Alternative approach using .gitignore:**
```bash
echo "*" > .gitignore
echo "!.gitignore" >> .gitignore
```

This creates a `.gitignore` that ignores all files except itself, preserving the directory.

## Committing Changes

### Creating Commits

**Commit staged changes with a message:**
```bash
git commit -m "Initial commit"
```

Commit messages should be clear, concise, and descriptive of the changes made.

**Commit with a detailed message:**
```bash
git commit
```

This opens your default text editor for writing a multi-line commit message. The first line should be a brief summary (50 characters or less), followed by a blank line and detailed description.

**Stage and commit in one command:**
```bash
git commit -am "Update feature implementation"
```

The `-a` flag automatically stages all modified and deleted tracked files before committing. Note: This doesn't include new untracked files.

**Amend the previous commit:**
```bash
git commit --amend -m "Corrected commit message"
```

This replaces the last commit with a new one, useful for fixing commit messages or adding forgotten changes.

### Commit Message Best Practices

**Conventional commit format:**
```
type(scope): subject

body

footer
```

**Common types:**
- `feat`: New feature
- `fix`: Bug fix
- `docs`: Documentation changes
- `style`: Code style changes (formatting, semicolons, etc.)
- `refactor`: Code refactoring
- `test`: Adding or updating tests
- `chore`: Maintenance tasks

**Example:**
```bash
git commit -m "feat(auth): implement JWT token authentication

- Add JWT token generation
- Implement token verification middleware
- Add refresh token functionality

Closes #123"
```

## Branch Management

### Working with Branches

**View all branches:**
```bash
git branch
```

The current branch is marked with an asterisk.

**View all branches including remote:**
```bash
git branch -a
```

**Create a new branch:**
```bash
git branch feature-name
```

**Switch to a branch:**
```bash
git checkout feature-name
```

**Create and switch to a new branch:**
```bash
git checkout -b feature-name
```

**Rename the current branch:**
```bash
git branch -m new-branch-name
```

**Rename a specific branch:**
```bash
git branch -m old-name new-name
```

**Delete a branch:**
```bash
git branch -d branch-name
```

**Force delete a branch (even if not merged):**
```bash
git branch -D branch-name
```

**Rename master to main:**
```bash
git branch -m master main
```

This updates your local branch name to follow modern naming conventions.

## Remote Repository Management

### Configuring Remote Repositories

**View configured remotes:**
```bash
git remote -v
```

This displays all remote repositories with their URLs for fetching and pushing.

**Add a remote repository:**
```bash
git remote add origin https://github.com/username/repository-name.git
```

The name "origin" is conventional for the primary remote repository.

**Remove a remote:**
```bash
git remote remove origin
```

**Rename a remote:**
```bash
git remote rename old-name new-name
```

**Change remote URL:**
```bash
git remote set-url origin https://github.com/username/new-repository.git
```

**Add multiple remotes:**
```bash
git remote add upstream https://github.com/original-owner/repository.git
```

This is useful for contributing to forked repositories.

## Pushing Changes to GitHub

### Uploading Local Commits

**Push to remote repository:**
```bash
git push origin main
```

This uploads commits from your local "main" branch to the "main" branch on the "origin" remote.

**Push and set upstream tracking:**
```bash
git push -u origin main
```

The `-u` flag sets the upstream tracking relationship, allowing you to use `git push` without specifying the remote and branch in future commands.

**Push all branches:**
```bash
git push --all origin
```

**Push tags:**
```bash
git push --tags
```

**Force push (use with caution):**
```bash
git push --force origin main
```

Force pushing overwrites remote history and should only be used when you're certain it won't affect collaborators.

**Safer force push:**
```bash
git push --force-with-lease origin main
```

This prevents overwriting work if the remote has been updated since your last fetch.

## Pulling and Fetching Changes

### Synchronizing with Remote Repositories

**Fetch changes from remote:**
```bash
git fetch origin
```

This downloads remote changes without merging them into your local branches.

**Pull changes and merge:**
```bash
git pull origin main
```

This fetches and merges changes from the remote "main" branch into your current branch.

**Pull with rebase:**
```bash
git pull --rebase origin main
```

This applies your local commits on top of the fetched commits, creating a linear history.

**Fetch all remotes:**
```bash
git fetch --all
```

## Viewing History and Changes

### Examining Repository History

**View commit history:**
```bash
git log
```

**View condensed history:**
```bash
git log --oneline
```

**View history with graph:**
```bash
git log --graph --oneline --all
```

**View history for a specific file:**
```bash
git log filename.txt
```

**View changes in commits:**
```bash
git log -p
```

**View last N commits:**
```bash
git log -n 5
```

### Inspecting Changes

**View unstaged changes:**
```bash
git diff
```

**View staged changes:**
```bash
git diff --staged
```

**View changes between branches:**
```bash
git diff branch1..branch2
```

**View changes for a specific file:**
```bash
git diff filename.txt
```

## Practical Example: Complete Workflow

### Setting Up a New Project and Pushing to GitHub

**Step 1: Create and navigate to project directory**
```bash
mkdir my-awesome-project
cd my-awesome-project
```

**Step 2: Initialize Git repository**
```bash
git init -b main
```

**Step 3: Create project files**
```bash
touch README.md
echo "# My Awesome Project" > README.md
echo "This is a sample project demonstrating Git workflow." >> README.md
```

**Step 4: Create a .gitignore file**
```bash
nano .gitignore
```

Add common ignore patterns:
```
node_modules/
.env
*.log
.DS_Store
```

**Step 5: Stage all files**
```bash
git add -A
```

**Step 6: Create initial commit**
```bash
git commit -m "Initial commit: Add README and .gitignore"
```

**Step 7: Connect to GitHub repository**
```bash
git remote add origin https://github.com/username/my-awesome-project.git
```

**Step 8: Push to GitHub**
```bash
git push -u origin main
```

## Advanced Example: C Program Development Workflow

### Creating, Compiling, and Version Controlling a C Program

**Step 1: Create project structure**
```bash
mkdir c-project
cd c-project
git init -b main
mkdir src build
```

**Step 2: Create C source file using echo**
```bash
echo '#include <stdio.h>

int main() {
    printf("Hello, World!\n");
    return 0;
}' > src/hello.c
```

**Step 3: Alternative - Create using Nano**
```bash
nano src/hello.c
```

Add the following code:
```c
#include <stdio.h>

int main() {
    printf("Hello, World!\n");
    return 0;
}
```

Save and exit (Ctrl + X, Y, Enter).

**Step 4: Create .gitignore for C projects**
```bash
echo '# Compiled files
*.o
*.exe
*.out
a.out

# Build directory
build/

# Editor files
*.swp
*~' > .gitignore
```

**Step 5: Compile the program**
```bash
gcc src/hello.c -o build/hello
```

**Step 6: Run the compiled program**
```bash
./build/hello
```

Expected output:
```
Hello, World!
```

**Step 7: Stage and commit source code**
```bash
git add src/hello.c .gitignore
git commit -m "feat: implement hello world program"
```

**Step 8: Push to GitHub**
```bash
git remote add origin https://github.com/username/c-project.git
git push -u origin main
```

## Common Git Scenarios and Solutions

### Undoing Changes

**Discard changes in working directory:**
```bash
git checkout -- filename.txt
```

**Unstage a file:**
```bash
git reset HEAD filename.txt
```

**Undo last commit (keep changes):**
```bash
git reset --soft HEAD~1
```

**Undo last commit (discard changes):**
```bash
git reset --hard HEAD~1
```

**Revert a commit (create new commit):**
```bash
git revert commit-hash
```

### Handling Merge Conflicts

When pulling or merging creates conflicts:

1. **Identify conflicted files:**
```bash
git status
```

2. **Open and resolve conflicts in each file**
3. **Stage resolved files:**
```bash
git add resolved-file.txt
```

4. **Complete the merge:**
```bash
git commit -m "Resolve merge conflicts"
```

### Stashing Changes

**Save work in progress:**
```bash
git stash
```

**View stashed changes:**
```bash
git stash list
```

**Apply most recent stash:**
```bash
git stash apply
```

**Apply and remove stash:**
```bash
git stash pop
```

**Apply specific stash:**
```bash
git stash apply stash@{2}
```

## Git Configuration

### Setting Up User Information

**Configure username:**
```bash
git config --global user.name "Your Name"
```

**Configure email:**
```bash
git config --global user.email "your.email@example.com"
```

**View configuration:**
```bash
git config --list
```

**Configure default editor:**
```bash
git config --global core.editor "nano"
```

**Configure default branch name:**
```bash
git config --global init.defaultBranch main
```

## Best Practices and Tips

### Commit Guidelines

1. **Commit frequently**: Make small, logical commits rather than large, monolithic ones
2. **Write clear messages**: Describe what and why, not how
3. **Test before committing**: Ensure code works before creating a commit
4. **Use branches**: Keep main branch stable, develop features in separate branches
5. **Review before pushing**: Check `git status` and `git diff` before pushing

### Repository Organization

1. **Use .gitignore**: Exclude build artifacts, dependencies, and sensitive files
2. **Include README**: Document project purpose, setup, and usage
3. **Add LICENSE**: Specify how others can use your code
4. **Structure directories**: Organize code logically (src, tests, docs, etc.)

### Collaboration Workflow

1. **Pull before push**: Always fetch latest changes before pushing
2. **Use pull requests**: Review code before merging to main branch
3. **Communicate**: Document changes and discuss major modifications
4. **Follow conventions**: Adhere to team's branching and commit message standards

## Troubleshooting Common Issues

### Authentication Problems

If you encounter authentication errors when pushing:

**Use personal access token (recommended):**
1. Generate token on GitHub (Settings → Developer settings → Personal access tokens)
2. Use token as password when prompted

**Configure credential helper:**
```bash
git config --global credential.helper cache
```

### Large File Issues

For files larger than GitHub's limits:

**Use Git LFS (Large File Storage):**
```bash
git lfs install
git lfs track "*.psd"
git add .gitattributes
```

### Accidental Commits

**Remove file from Git but keep locally:**
```bash
git rm --cached filename.txt
```

**Remove directory from Git:**
```bash
git rm -r --cached directory/
```

## Conclusion

Mastering Git commands and workflows is essential for efficient software development. This guide covers fundamental operations, from basic file management to advanced version control scenarios. Regular practice with these commands will build muscle memory and improve your development workflow.

Remember that Git is a powerful tool with many features beyond what's covered here. As you become comfortable with these basics, explore advanced topics like rebasing, cherry-picking, bisecting, and submodules to further enhance your version control capabilities.

For additional resources and detailed documentation, visit the official Git documentation at [git-scm.com](https://git-scm.com/doc).

---

**Quick Reference Summary:**

- Initialize: `git init`
- Stage: `git add .`
- Commit: `git commit -m "message"`
- Connect remote: `git remote add origin URL`
- Push: `git push -u origin main`
- Pull: `git pull origin main`
- Status: `git status`
- History: `git log`

---

*This guide is maintained and updated regularly to reflect current Git best practices and GitHub workflows.*
